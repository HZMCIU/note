[TOC]

# 配置

## 建立复制

**主从复制的特点：**

每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。

**配置开启主从复制：**

1. 在配置文件中加入`slaveof{masterHost}{masterPort}`随redis启动生效  
2. 在redis-server启动命令后加入`--slaveof{masterHost}{masterPort}`生效
3. 直接使用命令： `slaveof{masterHost}{masterPort}`生效    

**查看结点内部的状态：**

`info replication`

## 断开复制

**从节点断开与主节点的复制关系：**

`slave no one` 

**从节点切换主节点：**

`slave of no one ` `slave of {newMasterIp} {newMasterPort}`

1. 断开与旧主节点复制关系
2. 与新主节点建立复制关系
3. ==删除从节点当前所有数据== 
4. 对新主节点进行复制操作 

## 复制校验

对于数据比较重要的节点， 主节点会通过设置`requirepass`参数进行密码验证， 这时所有的客户端访问必须使用`auth`命令实行校验。  需要配置从节点的`masterauth`参数与主节点密码保持一致  

## 只读

从节点使用`slave-read-only=yes`配置为只读模式。 由于复制只能从主节点到从节点， 对于从节点的任何修改主节点都无法感知， 修改从节点会造成主从数据不一致  

## 传输延迟

Redis为我们提供了`repl-disable-tcp-nodelay`参数用于控制是否关闭`TCP_NODELAY`， 默认关闭  

当关闭时， 主节点产生的命令数据无论大小都会及时地发送给从节点， 这样主从之间延迟会变小， 但增加了网络带宽的消耗。 适用于主从之间的网络环境良好的场景， 如同机架或同机房部署  

当开启时， 主节点会合并较小的TCP数据包从而节省带宽。 默认发送时间间隔取决于Linux的内核， 一般默认为40毫秒。 这种配置节省了带宽但增大主从之间的延迟。 适用于主从网络环境复杂或带宽紧张的场景， 如跨机房部署  

# 拓扑

## 一主一从结构  

**结构：**用于主节点出现宕机时从节点提供故障转移支持 

**持久化：**当应用写命令并发量较高且需要持久化时， 可以只在从节点上开启AOF， 这样既保证数据安全性同时也避免了持久化对主节点的性能干扰 

当主节点关闭持久化功能时，如果主节点脱机要避免自动重启操作。 因为主节点之前没有开启持久化功能自动重启后数据集为空， 这时从节点如果继续复制主节点会导致从节点数据也被清空的情况， 丧失了持久化的意义。 安全的做法是在从节点上执行`slaveof no one`断开与主节点的复制关系， 再重启主节点从而避免这一问题。  

## 一主多从结构

一主多从结构（又称为星形拓扑结构） 使得应用端可以利用多个从节点实现读写分离。 对于读占比较大的场景， 可以把读命令发送到从节点来分担主节点压力。 同时在日常开发中如果需要执行一些比较耗时的读命令， 如： keys、 sort等， 可以在其中一台从节点上执行， 防止慢查询对主节点造成阻塞从而影响线上服务的稳定性。 

对于写并发量较高的场景， 多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽， 同时也加重了主节点的负载影响服务稳定性。  

## 树状主从结构  

树状主从结构（又称为树状拓扑结构） 使得从节点不但可以复制主节点数据， 同时可以作为其他从节点的主节点继续向下层复制。

 通过引入复制中间层， 可以有效降低主节点负载和需要传送给从节点的数据量。当主节点需要挂载多个从节点时为了避免对主节点的性能干扰， 可以采用树状主从结构降低主节点压力。  

# 原理

## 复制过程

1. **保存主节点信息**

   执行`slaveof`后从节点只保存主节点的地址信息便直接返回， 这时建立复制流程还没有开始  

2. **主从建立socket连接**

   从节点会建立一个socket套接字 ，专门用于接受主节点发送的复制命令 

3. **发送ping命令**

   连接建立成功后从节点发送ping请求进行首次通信， ping请求是为了

   + 检测主从之间网络套接字是否可用  
   + 检测主节点当前是否可接受处理命令 

4. **权限验证**

   如果主节点设置了`requirepass`参数， 则需要密码验证，从节点必须配置`masterauth`参数保证与主节点相同的密码才能通过验证。

5. **同步数据集**

   主从复制连接正常通信后， 对于首次建立复制的场景， 主节点会把持有的数据全部发送给从节点， 这部分操作是耗时最长的步骤  

6. **命令持续复制**

   主节点会持续地把写命令发送给从节点， 保证主从数据一致性  

# 数据同步

## `psync`命令

`psync{runId}{offset}` ，`runId`： 从节点所复制主节点的运行id。`offset`： 当前从节点已复制的数据偏移量，第一次复制时，默认为-1。

Redis在2.8版本以后采用新复制命令`psync`进行数据同步。`psync`需要以下组件的支持

+ 主从节点各自复制偏移量

  主节点（master） 在处理完写入命令后， 会把命令的字节长度做累加记录 。从节点在接收到主节点发送的命令后， 也会累加记录自身的偏移量。通过对比主从节点的复制偏移量，判断主从结点数据是否一致。`info replication`可以看到主从结点的复制偏移量。

+ 主节点复制积压缓冲区 

  保存在主节点上的一个固定长度的先进先出的队列。主节点（master）响应写命令时， 不但会把命令发送给从节点， 还会写入复制积压缓冲区。能实现保存最近已复制数据的功能， 用于部分复制和复制命令丢失的数据补救。  

+ 主节点运行id

  Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。 运行ID的主要作用是用来唯一识别Redis节点 。当主节点重启变更了整体数据集，通过运行ID来识别结点，避免不安全的增量复制。将变化后的数据全量同步到从节点。
  `info server`  可以查看当前结点的运行ID
  `debug reload` 可以重新加载RDB，并且运行时ID不变 

## 全量同步

一般用于初次复制场景， Redis早期支持的复制功能只有全量复制， 它会把主节点全部数据一次性发送给从节点， 当数据量较大时， 会对主从节点和网络造成很大的开销。  

1. 发送`psync`命令进行数据同步， 由于是第一次进行复制， 从节点没有复制偏移量和主节点的运行ID， 所以发送`psync-1`  

2. 主节点发送RDB文件给从节点， 从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件

   RDB文件从创建到传输完毕消耗的总时间如果超过`repl-timeout`所配置的值（默认60秒） ， 从节点将放弃接受RDB文件并清理已经下载的临时文件， 导致全量复制失败

3. 主节点发送RDB文件期间，会将写命令数据保存在**复制客户端缓冲区**内。

   如果60秒内缓冲区消耗持续大于64MB或者直接超过256MB时， 主节点将直接关闭复制客户端连接， 造成全量同步失败

4. 从节点成功加载完RDB后， 如果当前节点开启了AOF持久化功能，它会立刻做`bgrewriteaof`操作， 为了保证全量复制后AOF持久化文件立刻可用

## 部分复制

当从节点（slave） 正在复制主节点（master） 时， 如果出现网络闪断或者命令丢失等异常情况时， 从节点会向主节点要求补发丢失的命令数据， 如果主节点的**复制积压缓冲区**内存在这部分数据则直接发送给从节点， 这样就可以保持主从节点复制的一致性  

 ## 心跳

主从节点在建立复制后， 它们之间维护着长连接并彼此发送心跳命令  

1. 主节点默认每隔10秒对从节点发送ping命令， 判断从节点的存活性和连接状态  
2. 从节点在主线程中每隔1秒发送`replconf ack{offset}`命令， 给主节点上报自身当前的复制偏移量，监测主从节点网络状态 ，

## 异步复制

主节点不但负责数据读写， 还负责把写命令同步给从节点。 写命令的发送过程是异步完成， 也就是说主节点自身处理完写命令后直接返回给客户端， 并不等待从节点复制完成  

# 主从复制的问题

## 读写分离的问题

**数据延迟**

刚在主节点写入数据后立刻在从节点上读取可能获取不到。

需要业务场景允许短时间内的数据延迟。 对于无法容忍大量延迟场景， 可以编写外部监控程序监听主从节点的复制偏移量， 当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点  

**过期数据**

为了保证主从复制的一致性，从节点不会主动删除结点。当访问从节点时，可能获取到超时的数据。当主节点存储大量设置超时的数据时， 如缓存数据， Redis内部需要维护过期数据删除策略， 删除策略主要有两种： **惰性删除和定时删除**  。

**从节点故障**

从节点可能由于故障导致无法访问。对于从节点的故障问题， 需要在客户端维护可用从节点列表， 当从节点故障时立刻切换到其他从节点或主节点上  

## 主从配置不一致

主从结点内存相关的配置必须要一致。如果从节点的`maxmemory`小于主节点，在进行复制的时候，可能会造成从节点内存溢出，使得数据丢失。

## 全量复制

**结点运行ID不匹配**

主节点因故障重启， 那么它的运行ID会改变， 从节点发现主节点运行ID不匹配时， 会认为自己复制的是一个新的主节点从而进行全量复制。对于这种情况应该从架构上规避， 比如提供故障转移功能 。

**复制积压缓存区不足**

如果请求的偏移量不在主节点的积压缓冲区内， 则无法提供给从节点数据， 因此部分复制会退化为全量复制。对于大流量场景，需要增加积压缓存区。

## 复制风暴

复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。  

**单主节点复制风暴**

单主节点复制风暴一般发生在主节点挂载多个从节点的场景。当主节点重启恢复后， 从节点会发起全量复制流程， 这时主节点就会为从节点创建RDB快照， 如果在快照创建完毕之前， 有多个从节点都尝试与主节点进行全量同步， 那么其他从节点将共享这份RDB快照。  

但是， 同时向多个从节点发送RDB快照， 可能使主节点的网络带宽消耗严重， 造成主节点的延迟变大 。解决方案首先可以减少主节点（master） 挂载从节点（slave） 的数量，或者采用树状复制结构， 加入中间层从节点用来保护主节点。

**单机器复制风暴**

当一台机器（machine）上同时部署多个主节点（master）时启恢复，会有大量从节点（slave） 针对这台机器的主节点进行全量复制， 会造成当前机器网络带宽耗尽。

+ 应该把主节点尽量分散在多台机器上， 避免在单台机器上部署过多的主节点  
+ 当主节点所在机器故障后提供故障转移机制， 避免机器恢复后进行密集的全量复制  

# 参考资料

[^1]:《Redis开发与运维》