[TOC]



# `LOCK TABLES` 命令



# `FOR SHARE/UPDATE `命令[^4]

## `SELECT ... FOR SHARE`



# InnoDB锁

## 共享锁和独占锁

InnoDB内部实现了两种行级别的锁， shared(s) locks （共享锁）和 exclusive locks（独占锁）。

+ **共享锁：** 共享锁允许其他事务读取被锁住的数据行，也允许其他事务获取该数据行的共享锁，但是获取该数据行的独占锁是不被允许的
  + 如果事务T1拥有数据行r上的共享锁s，事务T2尝试获取同一数据行r上的共享锁s会被立刻批准。此时，事务T1和事务T2同时占有同一共享锁s
  + 如果事务T1拥有数据行r上的共享锁s，事务T2尝试获取同一数据行r上的独占锁x会被阻塞，等待事务T1的提交。
+ **独占锁：** 独占锁所锁住的数据行无法被其他事务读取或修改。同时，其他事务无法获取被独占锁所锁住的数据行的任何锁，无论是该行的独占锁还是共享锁。
  + 如果事务T1拥有数据行r上的独占锁x，事务T2尝试获取同一数据行上的共享锁s或独占锁x，都会被阻塞。

## 意向锁

InnoDB使用**意向锁**来支持不同粒度的锁共存，即行锁和表锁共存。意向锁是一种表锁，用来指示事务中对表中的数据行要加哪些锁。

## Record Locks



# 参考资料

[^1]:[MySQL 官方文档—InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)
[^2]:[MySQL 官方文档—-Lock Tables](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)
[^3]:[MySQL 官方文档—Locking Functions](https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html)
[^4]:[MySQL官方文档—Locking Reads](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)
[^5]: [MySQL的锁机制和加锁原理 ](https://blog.csdn.net/qq_38238296/article/details/88362999)
[^6]: [Mysql中的锁机制](https://www.cnblogs.com/leedaily/p/8378779.html)
[^7]:[MySQL的SELECT ...for update](https://www.cnblogs.com/wxgblogs/p/6849064.html)
[^8]:[数据库：Mysql中“select ... for update”排他锁分析](https://blog.csdn.net/claram/article/details/54023216)
[^9]:[mysql事务，select for update，及数据的一致性处理](https://www.cnblogs.com/houweijian/p/5869243.html)

[^10]: [MySQL 官方文档—InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)