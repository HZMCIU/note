[TOC]



# `LOCK TABLES` 命令 [^2]



# `FOR SHARE/UPDATE `命令[^4]

## `SELECT ... FOR SHARE`



# InnoDB锁[^1]

## 共享锁和独占锁

InnoDB内部实现了两种行级别的锁， shared(s) locks （共享锁）和 exclusive locks（独占锁）。

+ **共享锁：** 共享锁允许其他事务读取被锁住的数据行，也允许其他事务获取该数据行的共享锁，但是获取该数据行的独占锁是不被允许的
  + 如果事务T1拥有数据行r上的共享锁s，事务T2尝试获取同一数据行r上的共享锁s会被立刻批准。此时，事务T1和事务T2同时占有同一共享锁s
  + 如果事务T1拥有数据行r上的共享锁s，事务T2尝试获取同一数据行r上的独占锁x会被阻塞，等待事务T1的提交。
+ **独占锁：** 独占锁所锁住的数据行无法被其他事务读取或修改。同时，其他事务无法获取被独占锁所锁住的数据行的任何锁，无论是该行的独占锁还是共享锁。
  + 如果事务T1拥有数据行r上的独占锁x，事务T2尝试获取同一数据行上的共享锁s或独占锁x，都会被阻塞。

## 意向锁

InnoDB使用**意向锁**来支持不同粒度的锁共存，即行锁和表锁共存。意向锁是一种**表锁**，表明成功获取意向锁后，事务中对表中的数据操作要加哪些锁。意向锁分为两种

+ intension shared lock(IS)，事务对表加IS锁后，之后事务对表中的数据行操作会加共享锁。即，事务想要获取该表数据行上的共享锁，要首先获取该表上的IS锁。
+ intension exclusive lock(IX)，事务对表加IX锁后，之后事务对表中的数据行操作会加独占锁。即，事务想要获取该表数据行上的独占锁，首先要获取该表上的IX锁。

举个例子，`SELECT ... FOR SHARE`设置IS锁，`SELECT ... FOR UPDATE`设置IX锁。获取一张表的意向锁后，其他的锁表指令无法再起作用了（比如，`LOCK TABLES ... WRITE`），这样做的意图在于告知其他事务，当前事务==即将==对锁定该表的数据行。

事务获取表上的意向锁，如果不存在冲突，那么成功获取意向锁，否则获取失败。下表简述了各类锁之间的冲突关系。

|        |  **X**   |     **IX**     |   **S**    |     **IS**     |
| ------ | :------: | :------------: | :--------: | :------------: |
| **X**  | Conflict |    Conflict    |  Conflict  |    Conflict    |
| **IX** | Conflict | ==Compatible== |  Conflict  | ==Compatible== |
| **S**  | Conflict |    Conflict    | Compatible |   Compatible   |
| **IS** | Conflict | ==Compatible== | Compatible |   Compatible   |

## **Record Locks**

record locks使用索引来设置数据行上的锁，例如`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;`，`c1`为索引列，该查询语句会在所有`c1=10`的数据行上加上锁。

## Gap Locks

gap locks 能够对**一个范围内**的数据行进行加锁，gap locks 的加锁范围是基于索引来确定的。gap locks可以锁定索引值==**小于**==某个数值的数据，也可以锁定索引值**==大于==**某个数值的数据行，也锁定索引值位于某个区间范围内的数据行。被锁定的数据行可能为空，可能只有一个，也可能有多个，这主要取决于表内有多少数据落在gap locks确定的范围内。

+ `SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`，就会锁定所有$c1 \in (10,20)$的数据行，其他事务无法对该范围内的数据进行操作。
+ `SELECT * FROM child WHERE id=100`，如果`id`是非唯一索引或`id`不是索引，那么该查询语句会锁定`id`小于100的数据行。当然，`id`如果是唯一索引，那么只会锁定`id=100`这一行数据了。

同一个范围内允许存在多个 gap locks，无论这个gap locks是shared的还是exclusived的。

## Next-Key Locks

next-key locks是gap locks和index-record locks的一种组合，能够锁住索引值小于等于给定值的数据行。举个例子，给定一下索引值$10,11,13,20$，next-key locks锁定的范围是$(-\infty,10],(10,11],(11,13],(13,20]$ 。InnoDB内置的隔离级别是REPEATABLE READ，内部所采用的锁就是next-key locks，防止幻读。

## Insert Intention Locks

insert intension locks是由`insert`语句在执行插入操作之前设置的锁。insert intension locks的作用是，在一个加锁的范围内，多个事务尝试对同一范围内的进行插入操作，**如果这些不同事务的插入操作没有冲突，没有在同一个位置进行多次插入，那么插入操作便可以顺利执行。**例如，假定索引值位于4和7之间的数据都被锁定了，存在两个事务分别尝试插入索引值为5和6的数据行，由于索引值5和6并没有冲突，能够成功地进行插入操作。

# **参考资料**

[^1]:[MySQL 官方文档—InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)
[^2]:[MySQL 官方文档—-Lock Tables](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)
[^3]:[MySQL 官方文档—Locking Functions](https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html)
[^4]:[MySQL官方文档—Locking Reads](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)
[^5]: [MySQL的锁机制和加锁原理 ](https://blog.csdn.net/qq_38238296/article/details/88362999)
[^6]: [Mysql中的锁机制](https://www.cnblogs.com/leedaily/p/8378779.html)
[^7]:[MySQL的SELECT ...for update](https://www.cnblogs.com/wxgblogs/p/6849064.html)
[^8]:[数据库：Mysql中“select ... for update”排他锁分析](https://blog.csdn.net/claram/article/details/54023216)
[^9]:[mysql事务，select for update，及数据的一致性处理](https://www.cnblogs.com/houweijian/p/5869243.html)
[^10]: [MySQL 官方文档—InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)