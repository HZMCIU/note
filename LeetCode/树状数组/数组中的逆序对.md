#### [数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

### 解题思路

**归并排序**

归并排序将数组分割为若干有序的子段，并进行两两“向上”合并。

在一次合并过程中，第一段数组和第二段数组均为有序的，现使用$lptr$和$rptr$指示两个数组当前的位置。

倘若$A[lptr]<B[rptr]$，要将$A[lptr]$加入到目标数组中，易知$A[lptr]>B[0\cdots rptr-1]$，所以一共有$rptr-1$个逆序的数。

---



**树状数组**

使用`二分查找+排序`来对数组进行离散化，使用桶来保存元素的信息，桶中保存元素出现的次数，前缀和即表示为所有小于该元素的个数。

从后向前进行操作，假设目前的遍历的元素为$a_i$，利用前缀和，查找所有小于$a_i$的个数，然后将$a_i$加入到树状数组中去。



### AC代码

**树状数组**

```cpp
class BIT
{
private:
    vector<int> tree;
    int n;
public:
    BIT(int _n):n(_n),tree(_n+1){}

    static int lowbit(int x)
    {
        return x&-x;
    }

    int query(int x)
    {
        int res=0,i=1;
        while(x)
        {
            res+=tree[x];
            x-=lowbit(x);
        }
        return res;
    }

    void update(int x)
    {
        while(x<=n)
        {
            ++tree[x];
            x+=lowbit(x);
        }
    }
};


class Solution
{
public:
    int reversePairs(vector<int>& nums)
    {
        vector<int> temp=nums;
        sort(temp.begin(),temp.end());
        for(int &num:nums)
        {
            num=lower_bound(temp.begin(),temp.end(),num)-temp.begin()+1;
        }

        int res=0;
        int n=nums.size();
        BIT bit(n);
        for(int i=n-1;i>=0;i--)
        {
            res+=bit.query(nums[i]-1);
            bit.update(nums[i]);
        }
        return res;
    }
};

```

**归并排序**

```cpp
class Solution
{
public:
    int reversePairs(vector<int>& nums)
    {
        int n=nums.size();
        vector<int> temp(n+1);
        return mergeSort(nums, temp, 0, n-1);
    }

    int mergeSort(vector<int> &nums, vector<int> &temp, int l, int r)
    {
        if(l >= r)
            return 0;
        int mid = (l + r) / 2;
        int res = mergeSort(nums, temp, l, mid) + mergeSort(nums, temp, mid + 1, r);
        int i = l, j = mid + 1;
        int cur = l;
        while(i <= mid && j <= r)
        {
            if(nums[i] <= nums[j])
            {
                temp[cur] = nums[i];
                res += (j - (mid + 1));
                i++;
                cur++;
            }
            else
            {
                temp[cur] = nums[j];
                j++;
                cur++;
            }
        }
        while(j <= r)
        {
            temp[cur++] = nums[j++];
        }
        while(i <= mid)
        {
            temp[cur]=nums[i];
            res+=(j-(mid+1));
            i++;
            cur++;
        }
        for(int i = l; i <= r; i++)
        {
            nums[i] = temp[i];
        }
        return res;
    }
};
```

