#### [数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

### 解题思路

**双堆**

​	使用两个堆，一个大顶堆，一个小顶堆。大顶堆中存放数组的前半部分，小顶堆中存放数组的后半部分。使用两个堆的堆顶信息，就可以获得中位数的信息。

​	添加一个数num,先将num加入到大顶堆mx中，弹出mx顶部的数，加入到小顶堆mi中去。如果此时mi的大小，大于mx的大小，开始调整二者的平衡性。

**multiset**

​	使用multiset来模拟平衡二叉树，使用两个迭代器指针来指向中间的两个值。

---

**双堆**

### AC代码

**双堆**

```cpp
class MedianFinder {
private:
    priority_queue<int> mx;
    priority_queue<int,vector<int>,greater<int>> mi;
public:
    /** initialize your data structure here. */
    
    void addNum(int num) {
        mx.push(num);
        mi.push(mx.top());
        mx.pop();
        if(mi.size()>mx.size())
        {
            mx.push(mi.top());
            mi.pop();
        }
    }
    
    double findMedian() {
        const int n=mx.size()+mi.size();
        if(n&1) 
            return mx.top();
        else 
            return (mi.top()+mx.top())*0.5;
    }
};
```

**multiset**

```cpp
class MedianFinder {
private:
    multiset<int> data;
    multiset<int>::iterator lo_median,hi_median;
public:
    /** initialize your data structure here. */
    MedianFinder():lo_median(data.end()),hi_median(data.end()) {}
    
    void addNum(int num) {
        const size_t n=data.size();
        data.insert(num);
        if(!n)
            lo_median=hi_median=data.begin();
        else if(n&1)
        {
            if(*lo_median>num)
                lo_median--;
            else if(*lo_median<=num)
                hi_median++;
        }
        else
        {
            if(*lo_median<num&&num<*hi_median)
            {
                --hi_median;
                ++lo_median;
            }
            else if(num>=*hi_median)
                ++lo_median;
            else
                lo_median=--hi_median;
        }
    }
    
    double findMedian() {
        return (*lo_median+*hi_median)*0.5;
    }
};
```



