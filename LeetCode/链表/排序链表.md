###  [排序链表](https://leetcode-cn.com/problems/sort-list/)

### 题意

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：

+ 你可以在 $O(n log n)$ 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

### 思路

#### 方法一：自顶向下归并排序

+ 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用==快慢指针==的做法，快指针每次移动2步，慢指针每次移动1步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。

+ 对两个子链表分别排序。

+ 将两个排序后的子链表合并，得到完整的排序后的链表。

#### 方法二：自底向上归并排序

+ 用 $subLength$表示每次需要排序的子链表的长度，初始时 $subLength=1$​
+ 
+ 每次将链表拆分成若干个长度为$subLength $的子链表（最后一个子链表的长度可以小于$subLength$），按照每两个子链表一组进行合并，合并后即可得到若干个长度为$ \textit{subLength} \times 2$的有序子链表（最后一个子链表的长度可以小于$ \textit{subLength} \times 2$。
+ 将$ \textit{subLength}$的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 $\textit{length}$，整个链表排序完毕。

### AC代码

#### 自顶向下归并排序

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sortList(head, null);
    }

    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummy = new ListNode();
        ListNode tmp = dummy, tmp1 = head1, tmp2 = head2;

        while (tmp1 != null && tmp2 != null) {
            if (tmp1.val <= tmp2.val) {
                tmp.next = tmp1;
                tmp = tmp1;
                tmp1 = tmp1.next;
            } else {
                tmp.next = tmp2;
                tmp = tmp2;
                tmp2 = tmp2.next;
            }
        }
        if (tmp1 != null)
            tmp.next = tmp1;
        else if (tmp2 != null)
            tmp.next = tmp2;
        return dummy.next;
    }

    public ListNode sortList(ListNode head, ListNode tail) {
        if (head == null)
            return head;
        if (head.next == tail) {
            head.next = null;
            return head;
        }

        ListNode fast = head, slow = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast.next != tail)
                fast = fast.next;
        }
        ListNode mid = slow;
        ListNode list1 = sortList(head, mid);
        ListNode list2 = sortList(mid, tail);
        return merge(list1, list2);
    }
}
```

#### 自底向上归并排序

```java
class Solution {
    public ListNode sortList(ListNode head) {
        int length = 0;
        ListNode cur = head;
        ListNode dummy = new ListNode();
        dummy.next = head;

        while (cur != null) {
            length++;
            cur = cur.next;
        }
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            ListNode pre = dummy;
            cur = dummy.next;
            ListNode head1 = null, head2 = null;

            while (cur != null) {
                head1 = cur;
                for (int i = 1; i < subLength && cur.next != null; i++) {
                    cur = cur.next;
                }
                head2 = cur.next;
                cur.next = null;

                cur = head2;
                for (int i = 1; i < subLength && cur != null; i++) {
                    cur = cur.next;
                }

                ListNode tmp = null;
                if (cur != null) {
                    tmp = cur.next;
                    cur.next = null;
                }

                ListNode merged = merge(head1, head2);
                pre.next = merged;

                while (pre.next != null) {
                    pre = pre.next;
                }

                cur = tmp;
            }
        }
        return dummy.next;
    }

    public ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummy = new ListNode();
        ListNode tmp = dummy;
        ListNode tmp1 = head1, tmp2 = head2;
        while (tmp1 != null && tmp2 != null) {
            if (tmp1.val <= tmp2.val) {
                tmp.next = tmp1;
                tmp = tmp1;
                tmp1 = tmp1.next;
            } else {
                tmp.next = tmp2;
                tmp = tmp2;
                tmp2 = tmp2.next;
            }
        }
        if (tmp1 != null)
            tmp.next = tmp1;
        else if (tmp2 != null)
            tmp.next = tmp2;
        return dummy.next;
    }
}
```

