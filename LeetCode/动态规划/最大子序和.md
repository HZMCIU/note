#### [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

### 解题思路

1. **动态规划**

   $dp[i]$：以$nums[i]$结尾最大子序列和

   状态转移方程：$dp[i]=max(nums[i],dp[i-1]+nums[i])$

   空间优化：使用$pre$来代替dp数组

2. 

### AC代码

**动态规划**

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size()+10);

        int ans=nums[0];
        dp[0]=nums[0];
        for(int i=1;i<nums.size();i++)
        {
            dp[i]=max(nums[i],dp[i-1]+nums[i]);
            ans=max(ans,dp[i]);
        }
        return ans;
    }
};
```

