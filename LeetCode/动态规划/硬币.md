#### [面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)



### 解题思路

定义状态$f(i,v)$。使用前$i$种硬币，凑到$v$的方案数。得到如下状态转移方程
$$
f(i,v)=f(i-1,v)+f(i-1,v-c_i)+\cdots +f(i-1,v-k*c_i)\\
f(i,v-c_i)=f(i-1,v-c_i)+f(i-1,v-2*c_i)+\cdots+f(i-1,v-k*c_i)\\

\Rightarrow f(i,v)=f(i-1,v)+f(i,v-c_i)
$$


$n=i\times 25+a_0\times 10+b_0\times 5+ c_0$

从总金额中取走最多$i$个25分硬币。

在剩余的金额中，取走最多$a_0$个10分硬币。

在剩余的金额中，取走最多$b_0$个5分硬币。

剩余的金额，为1分硬币。

---

假设目前取$i$个25分硬币，取$x$个10分硬币，则剩余的金额为$10(a_0-x)+5b_0+c_0$ 。

5分钱一共有$[0,2a_0+b_0-x]$ ，共$2a_0+b_0-x+1$个选择。剩余的为一分钱。

可知，在取$i$个25分钱的前提下。一共有$\sum_{x=0}^{a_0}(2a_0+b_0-x+1)=(a_0+b_0+1)(a_0+1)$种选择。

累加所有25分钱$[0,i]$共$i+1$种情况，得到答案。

### AC代码

动态规划法

```cpp
class Solution {
private:
    static constexpr int mod=1000000007;
    static constexpr int coins[4]={1,5,10,25};
public:
    int waysToChange(int n) {
        vector<int> dp(n+10);

        dp[0]=1;
        for(int i=0;i<4;i++){
            int coin=coins[i];
            for(int j=coin;j<=n;j++){
                dp[j]=dp[j-coin]+dp[j];
                dp[j]%=mod;
            }
        }
        return dp[n];
    }
};
```

数学法

``` cpp
class Solution {
private:
    static constexpr int mod=1000000007;
public:
    int waysToChange(int n) {
        long long res=0;
        for(int i=0;i<=n/25;i++){
            int r=n-25*i;
            int a=r/10;
            int b=(r%10)/5;
            int c=n-25*i-10*a-5*b;
            res+=(long long)(a+b+1)*(a+1);
            res%=mod;
        }
        return res;
    }
};
```
