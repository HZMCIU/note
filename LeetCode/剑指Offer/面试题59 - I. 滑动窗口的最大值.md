### [面试题59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

### 题目

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

### 思路

#### 优先队列

假设滑动窗口左侧不移动，右侧不断移动并增大范围。对于这种情况， **优先队列**能够动态获取该范围中的最大值，此刻堆顶元素就是区域内的最大值。

本题中，滑动窗口的左侧也不断移动，这就会造成堆顶元素不在滑动窗口的范围内， **<font color="red">这就需要将不在滑动窗口范围内的堆顶元素弹出</font>**。因此，需要保存堆顶元素的所在下标的位置。

#### 单调队列

假设滑动窗口为$[i,i+k-1]$ ，窗口内的最大值为$num[j]$ 。当窗口在不断移动过程中，$nums[i \cdots j-1]$均不可能为最大值， **在$nums[j]$弹出后，$nums[j \cdots i+k-1]$中会有一个值成为最大值**。

使用 **单调队列** 保存 $nums[j+1 \cdots i+k-1]$ 中所有可能的最大值。队首元素就是当前滑动窗口的最大值。为了方便单调队列弹出不在滑动窗口中的元素， **单调队列存储数组元素的下标**。

**单调队列的操作**

* 滑动窗口右端加入元素时，若新加入元素大于队尾元素，则不断弹出队尾元素，直至队尾元素大于新加入的元素
* 滑动窗口左端删除元素后，如果队首元素位于滑动窗口之外，则弹出队首元素

#### 前后缀+分块

将数组以滑动窗口大小$k$ 为一组分为若干组。从前往后遍历遍历数组$num[0 \cdots n-k]$ 。
* $i$ 为$k$ 的倍数，$nums[i]$ 为分组的第一个元素，滑动窗口的最大值恰好为该分组的最大值
* $i$ 不为 $k$ 的倍数，滑动窗口$nums[i \cdots i+k-1]$，跨越了两个分组，分别是前一个分组的后缀和后一个分组的前缀。
    * 预处理每个分组，计算出每个分组的前缀最大值`prefixMax`和后缀最大值`suffixMax`
    * 滑动窗口内的最大值 `res[i]=Math.max(suffixMax[i],prefixMax[i+k-1])`

### AC代码

**优先队列**
```java
import java.util.*;
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0) {
            return new int[] {};
        }
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int []>() {
            public int compare(int [] pair1, int [] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });
        for (int i = 0; i < k; i++) {
            pq.offer(new int[] {nums[i], i});
        }
        int n = nums.length;
        int [] res = new int[n - k + 1];
        int i = 0;
        for (int j = k; j <= n; j++) {
            while (!pq.isEmpty() && pq.peek()[1] < i) {
                pq.poll();
            }
            res[j - k] = pq.peek()[0];
            if (j < n) {
                pq.add(new int[] {nums[j], j});
            }
            i += 1;
        }
        return res;
    }
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(Arrays.toString(sol.maxSlidingWindow(new int[] {1, 3, -1, -3, 5, 3, 6, 7}, 3)));
    }
}

```

**单调队列**

```java
import java.util.*;
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0) {
            return new int[] {};
        }
        Deque<Integer> deque = new LinkedList<>();
        int n = nums.length;
        int [] res = new int[n - k + 1];
        for (int i = 0; i < k; i++) {
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.pollLast();
            }
            deque.add(i);
        }
        int i = 0;
        for (int j = k; j <= n; j++) {
            res[j - k] = nums[deque.peekFirst()];

            i += 1;
            if (j < n) {
                while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[j]) {
                    deque.pollLast();
                }
                deque.add(j);
            }
            while (!deque.isEmpty() && deque.peek() < i) {
                deque.pollFirst();
            }
        }
        return res;
    }
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(Arrays.toString(sol.maxSlidingWindow(new int[] {1, 3, -1, -3, 5, 3, 6, 7}, 3)));
    }
}

```

**前后缀+分块**

```java
import java.util.*;
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0) {
            return new int[] {};
        }
        int n = nums.length;
        int[] prefixMax = new int[n];
        int[] suffixMax = new int[n];
        for (int i = 0; i < n; i++) {
            if (i % k == 0) {
                prefixMax[i] = nums[i];
            } else {
                prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);
            }
        }

        for (int i = n - 1; i >= 0; i--) {
            if (i == n - 1 || (i + 1) % k == 0) {
                suffixMax[i] = nums[i];
            } else {
                suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);
            }
        }
        int []res = new int[n - k + 1];
        for (int i = 0; i < n - k + 1; i++) {
            res[i] = Math.max(suffixMax[i], prefixMax[i + k - 1]);
        }
        return res;
    }
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(Arrays.toString(sol.maxSlidingWindow(new int[] {1, 3, -1, -3, 5, 3, 6, 7}, 3)));
    }
}

```

