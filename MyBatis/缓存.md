[toc]

# MyBatis缓存机制

**MyBatis**将数据缓存设计成两级结构，分为一级缓存、二级缓存[^1]：

​    **一级缓存是Session会话级别的缓存**，位于表示一次数据库会话的**`SqlSession`**对象之中，又被称之为本地缓存。一级缓存是**MyBatis**内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）；

​    **二级缓存是**Application**应用级别的缓存**，它的是生命周期很长，跟**Application**的声明周期一样，也就是说它的作用范围是整个**Application**应用。

  **MyBatis**中一级缓存和二级缓存的组织如下图所示：

![](mybatis缓存机制示意图.png)

# 一级缓存

## 什么是一级缓存

MyBatis会在表示会话的`SqlSession`对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。[^2]

如下图所示，MyBatis会在一次会话的表示----一个`SqlSession`对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。

![](mybatis一级缓存.png)

## 一级缓存的如何在`SqlSession`中组织

 由于MyBatis使用`SqlSession`对象表示一次数据库的会话，那么，对于会话级别的一级缓存也应该是在`SqlSession`中控制的。

实际上, MyBatis只是一个MyBatis对外的接口，`SqlSession`将它的工作交给了`Executor`执行器这个角色来完成，负责完成对数据库的各种操作。**当创建了一个`SqlSession`对象时，MyBatis会为这个`SqlSession`对象创建一个新的Executor执行器，而缓存信息就被维护在这个`Executor`执行器中，MyBatis将缓存和对缓存相关的操作封装成了`Cache`接口中。**`SqlSession`、`Executor`、`Cache`之间的关系如下列类图所示：

![](Sqlsession关系类图.png)

如上述的类图所示，`Executor`接口的实现类`BaseExecutor`中拥有一个`Cache`接口的实现类`PerpetualCache`，则对于`BaseExecutor`对象而言，它将使用`PerpetualCache`对象维护缓存。

综上，`SqlSession`对象、Executor对象、Cache对象之间的关系如下图所示：

![](SqlSession对象关系.png)

## 一级缓存的生命周期

1. MyBatis在开启一个数据库会话时，会 创建一个新的`SqlSession`对象，`SqlSession`对象中会有一个新的`Executor`对象，`Executor`对象中持有一个新的`PerpetualCache`对象；当会话结束时，`SqlSession`对象及其内部的`Executor`对象还有`PerpetualCache`对象也一并释放掉。

2. 如果`SqlSession`调用了`close()`方法，会释放掉一级缓存`PerpetualCache`对象，一级缓存将不可用；

3. 如果`SqlSession`调用了`clearCache()`，会清空`PerpetualCache`对象中的数据，但是该对象仍可使用；

4. `SqlSession`中执行了任何一个`update`操作(`update()、delete()、insert()`) ，都会清空`PerpetualCache`对象的数据，但是该对象可以继续使用；

## 一级缓存的工作流程

1. 对于某个查询，根据`statementId`,`params`,`rowBounds`来构建一个key值，根据这个key值去缓存`Cache`中取出对应的key值存储的缓存结果；

2.  判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；
3.  如果命中，则直接将缓存结果返回；
4.  如果没命中：
   1. 去数据库中查询数据，得到查询结果；
   2. 将key和查询到的结果分别作为key,value对存储到Cache中；
   3. 将查询结果返回；
5. 结束

## Cache接口的设计以及`CacheKey`的定义

###  Cache接口

如下图所示，MyBatis定义了一个`org.apache.ibatis.cache.Cache`接口作为其`Cache`提供者的SPI(Service Provider Interface) ，所有的MyBatis内部的`Cache`缓存，都应该实现这一接口。MyBatis定义了一个`PerpetualCache`实现类实现了`Cache`接口，实际上，在`SqlSession`对象里的`Executor `对象内维护的`Cache`类型实例对象，就是`PerpetualCache`子类创建的。

![](Cache接口类图.png)

### `CacheKey`

**如何确定一次查询的特征值，即，怎样判断两次查询是完全相同的查询**

**MyBatis**认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询：

1. 传入的 **`statementId`**
2. 查询时要求的结果集中的结果范围 （结果的范围通过**`rowBounds.offset`**和**`rowBounds.limit`**表示）；
3. 这次查询所产生的最终要传递给JDBC **`java.sql.Preparedstatement`**的SQL语句字符串（**`boundSql.getSql()`** ）
4. 传递给**`java.sql.Statement`**要设置的参数值

3和4最本质的要求就是**调用JDBC的时候，传入的SQL语句要完全相同，传递给JDBC的参数值也要完全相同**。

综上所述,`CacheKey`由以下条件决定：

​							<span style="color:red">**`statementId  `+ `rowBounds  `+ 传递给JDBC的SQL  + 传递给JDBC的参数值**</span>

对于每次的查询请求，`Executor`都会根据传递的参数信息以及动态生成的SQL语句，将上面的条件根据一定的计算规则，创建一个对应的`CacheKey`对象。

## 性能分析

1. MyBatis对会话（Session）级别的一级缓存设计的比较简单，就简单地使用了`HashMap`来维护，并没有对`HashMap`的容量和大小进行限制
   1.   一般而言`SqlSession`的生存时间很短。一般情况下使用一个`SqlSession`对象执行的操作不会太多，执行完就会消亡
   2.  对于某一个`SqlSession`对象而言，只要执行update操作（`update`、`insert`、`delete`），都会将这个`SqlSession`对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响JVM内存空间的问题
   3. 可以手动地释放掉`SqlSession`对象中的缓存
2. 一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念

# 二级缓存

## 二级缓存的工作机制

![](mybatis缓存机制示意图.png)

​     如上图所示，当开一个会话时，一个`SqlSession`对象会使用一个`Executor`对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个`Executor`对象做文章。如果用户配置了"`cacheEnabled=true`"，那么MyBatis在为`SqlSession`对象创建`Executor`对象时，会对**`Executor`对象加上一个装饰者：`CachingExecutor`**，这时`SqlSession`使用`CachingExecutor`对象来完成操作请求。`CachingExecutor`对于查询请求，会**先判断该查询请求在Application级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的Executor对象来完成查询操作**，之后`CachingExecutor`会将真正`Executor`返回的查询结果放置到缓存中，然后在返回给用户。[^3] 

​	

![](mybatis二级缓存工作模式.png)

## 二级缓存的划分

MyBatis并不是简单地对整个Application就只有一个`Cache`缓存对象，它将缓存划分的更细，**即是Mapper级别的**，即每一个Mapper都可以拥有一个`Cache`对象，具体如下：

1. 为每一个Mapper分配一个Cache缓存对象（使用`<cache>`节点配置）

   MyBatis将Application级别的二级缓存细分到Mapper级别，即对于每一个Mapper.xml,如果在其中使用了`<cache> `节点，则MyBatis会为这个Mapper创建一个`Cache`缓存对象。每一个`Cache`对象，都会有一个自己所属的namespace命名空间，并且会将Mapper的 namespace作为它们的ID。

2. 多个Mapper共用一个Cache缓存对象（使用`<cache-ref>`节点配置）

   如果你想让多个Mapper公用一个Cache的话，你可以使用`<cache-ref namespace="">`节点，来指定你的这个Mapper使用到了哪一个Mapper的`Cache`缓存。

## 二级缓存必备的条件

MyBatis对二级缓存的支持粒度很细，它会指定某一条查询语句是否使用二级缓存。

要想使某条`Select`查询支持二级缓存，你需要保证：

1. MyBatis支持二级缓存的总开关：全局配置变量参数  ` cacheEnabled=true`
2. 该select语句所在的Mapper，配置了`<cache> `或`<cached-ref>`节点，并且有效
3. 该select语句的参数` useCache=true`

二级缓存需要查询结果映射的POJO对象实现`java.io.Serializable`接口实现序列化和反序列化操作，注意如果存在父类、成员POJO都需要实现序列化接口。POJO类实现序列化接口是为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存有可能是硬盘或者远程服务器。

## 一级二级缓存使用的顺序

  请注意，如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存，即MyBatis查询数据的顺序是：==二级缓存    ———> 一级缓存——> 数据库==

## 实现选择

MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的`Cache`缓存实现类，并提供了各种缓存刷新策略如LRU，FIFO等等；另外，MyBatis还允许用户自定义`Cache`接口实现，用户是需要实现`org.apache.ibatis.cache.Cache`接口，然后将`Cache`实现类配置在`<cache  type="">`节点的type属性上即可；除此之外，MyBatis还支持跟第三方内存缓存库如Memecached的集成，总之，使用MyBatis的二级缓存有三个选择:     

1. MyBatis自身提供的缓存实现；
2. 用户自定义的Cache接口实现；
3. 跟第三方内存缓存库的集成；

### MyBatis提供的二级缓存实现

MyBatis定义了大量的Cache的装饰器来增强Cache缓存的功能，如下类图所示。

+ 对于每个Cache而言，都有一个容量限制，MyBatis各供了各种策略来对Cache缓存的容量进行控制，以及对Cache中的数据进行刷新和置换。MyBatis主要提供了以下几个刷新和置换策略：
+ LRU：（Least Recently Used）,最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近做少被使用的缓存记录清除掉，然后添加新的记录；
+ Scheduled：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将Cache缓存中的数据清空；

![](Cache接口装饰器.png)

## 注意点

### 清空缓存

在mapper的同一个`namespace`中，如果有其它`insert`、`update`、`delete`操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。 设置statement配置中的`flushCache="true"` 属性，默认情况下为`true`即刷新缓存，如果改成`false`则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。[^4]

```xml
<insert id="insertUser" parameterType="cn.itcast.mybatis.po.User" flushCache="true">
```

总结：一般下执行完commit操作都需要刷新缓存，`flushCache=true`表示刷新缓存默认情况下为true,我们不用去设置它，这样可以避免数据库脏读。



[^1]:[MyBatis缓存机制的设计与实现](https://louluan.blog.csdn.net/article/details/41390801)

[^2]:[MyBatis的一级缓存实现详解 及使用注意事项](https://louluan.blog.csdn.net/article/details/41280959)
[^3]:[MyBatis的二级缓存的设计原理](https://blog.csdn.net/luanlouis/article/details/41408341)

[^4]:[mybatis的缓存机制（一级缓存二级缓存和刷新缓存）和mybatis整合ehcache](https://blog.csdn.net/u012373815/article/details/47069223)

